
# v14 Iteration

This iteration of the ColdFusion + HTMX application adds a "Delete" action to the list of contacts. This allows each contact to be deleted without leaving the context of the contacts list.

In the book, this feature was implemented by making a request to the original delete page; and then, conditionally changing the response based on the existence of the HTMX HTTP headers. I've chosen to go a different route. Instead of re-purposing the existing delete page - and tightly coupling it to multiple contexts - I've created a new deletion end-point that is specifically designed for the index page.

Now, I have three index-related pages:

* `index.cfm`
* `index.count.cfm`
* `index.delete.cfm` - the new one for this iteration.

So, we already have an established pattern of creating small, sibling utility end-points for page-specific operations.

To implement this, I added a `<button>` to each row that calls the `index.delete.cfm` file using an `hx-delete` request:

```cfm
<cfloop array="#contacts#" item="contact">
	<tr>
		<td />
		<td />
		<td />
		<td>
			<button
				hx-sync="this"
				hx-delete="index.delete.cfm?id=#...#"
				hx-target="closest tr"
				hx-swap="outerHTML"

				class="link-button">
				Delete
			</button>
		</td>
	</tr>
</cfloop>
```

Notice that the the `hx-target` replaces the closest `<tr>`. This new row content is generated by the new `index.delete.cfm` page:

```cfm
<cfscript>

	// ... truncated validation ...

	contactModel.deleteByFilter( id = contact.id );

	header
		name = "HX-Trigger"
		value = "contactDeleted"
	;

</cfscript>
<cfoutput>

	<tr class="deleted-row">
		<td colspan="4" style="text-align: center ;">
			#encodeForHtml( contact.name )# as been deleted.
		</td>
	</tr>

</cfoutput>
```

There are two things to notice in this tailor-made page. First, it's returning the new `<tr>` that's going to replace the original row in the table. So the inline delete doesn't actually _remove_ the row; more so, it demarcates it as _having been_ deleted. I think this reduces some of the potential jarring user experience.

Second, the deletion end-point is sending back the HTMX HTTP response header, `HX-Trigger`. This will cause the `contactDeleted` event to be fired on the client where we can use it to re-fetch the contacts count:

```cfm
<span
	hx-sync="this:replace"
	hx-get="index.count.cfm"
	hx-trigger="
		revealed,
		contactDeleted from:body
	">
	<!--- Lazy load the contacts length. --->
	(loading count...)
</span>
```

Now, the (artificially) expensive "contact count" request will be initiated on both "revealed" and "contactDeleted" events.

This isn't a perfect solution; but, I do like the idea of creating small sub-pages for actions like this so that I can collocate behavior and reduce coupling across different sections of the application.

See [relevant chapter in Hypermedia Systems][hypermedia-chapter]. It's the section labeled, "Inline Delete".


[hypermedia-chapter]: https://hypermedia.systems/more-htmx-patterns/#_inline_delete
